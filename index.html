<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Demo Phaser Game</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.2.1/dist/phaser.js"></script>
    <link rel="preload" as="font" href="assets/PublicPixel.ttf" type="font/ttf" crossorigin/>
</head>

<body>
    <style>
        @font-face {
            font-family: PublicPixel;
            src: url('assets/PublicPixel.ttf');
        }
    </style>
    <script>


class PauseMenu extends Phaser.Scene {
        
        constructor() {
            super('PauseMenu');
        }

        preload()
        {

        }
        
        create(data) {

            var rref = this;

            let box = rref.add.sprite((rref.sys.game.config.width / 2), (ref.sys.game.config.height / 2), 'box');
            box.setScale(0.4,0.4);
            rref.add.text((ref.sys.game.config.width / 2)-115, (rref.sys.game.config.height / 2)-110, 'PAUSED', { fontFamily: 'PublicPixel', fontSize:'40px' });
            let retry = rref.add.sprite(rref.sys.game.config.width / 2, (rref.sys.game.config.height / 2)+30, 'resume');
                retry.setScale(0.200,0.200);
                retry.setInteractive();

                retry.on('pointerover', () => { 
                    retry.tint = Math.random() * 0xffffff;
                    retry.setScale(0.201,0.201);
                });

                retry.on('pointerout', () => { 
                    retry.tint = 0xffffff;
                    retry.setScale(0.200,0.200);
                });

                retry.on('pointerdown', () => { 
                    retry.setScale(0.200,0.200);
                    ref.scene.resume();   
                    rref.scene.stop();
                });

                let quit = rref.add.sprite(rref.sys.game.config.width / 2, (rref.sys.game.config.height / 2)+100, 'quit');
                quit.setScale(0.200,0.200);
                quit.setInteractive();

                quit.on('pointerover', () => { 
                    quit.tint = Math.random() * 0xffffff;
                    quit.setScale(0.201,0.201);
                });

                quit.on('pointerout', () => { 
                    quit.tint = 0xffffff;
                    quit.setScale(0.200,0.200);
                });

                quit.on('pointerdown', () => { 
                    quit.setScale(0.200,0.200);
                    ref.scene.launch('Menu');
                    ref.scene.bringToTop('Menu');
                    rref.scene.stop();
                });
        }

        update() {}
}


class InGame extends Phaser.Scene {
        
    
        constructor() {
            super('InGame');
            ref = this;
        }

        preload()
        {
            if(!preloadedGame) {
                preloadedGame = Boolean(1);
                // Setting up Animations
                var frameNames;
                frameNames = ref.anims.generateFrameNames('spritesheet', {
                     start: 0, end: 3,
                     prefix: 'coin_anim_f'
                });
                ref.anims.create({ key: 'coinSpin', frames: frameNames, frameRate: 8, repeat: -1 });
                frameNames = ref.anims.generateFrameNames('spritesheet', {
                     start: 0, end: 3,
                     prefix: 'goblin_run_anim_f'
                });
                ref.anims.create({ key: 'goblinRun', frames: frameNames, frameRate: 8, repeat: -1 });
                frameNames = ref.anims.generateFrameNames('spritesheet', {
                     start: 0, end: 3,
                     prefix: 'knight_f_idle_anim_f'
                });
                ref.anims.create({ key: 'idle', frames: frameNames, frameRate: 8, repeat: -1 });
                frameNames = ref.anims.generateFrameNames('spritesheet', {
                        start: 0, end: 3,
                        prefix: 'knight_f_run_anim_f'
                });
                ref.anims.create({ key: 'run', frames: frameNames, frameRate: 8, repeat: -1 });
                

                frameNames = ref.anims.generateFrameNames('swordtrail', {
                        start: 0, end: 2                
                });
                ref.anims.create({ key: 'sword', frames: frameNames, frameRate: 8, repeat: 0 });
                
            }
        }
        
        create(data) {
            
            cursors = this.input.keyboard.createCursorKeys();

            // Groups:
            // all static objects / colliders
            var statics = this.physics.add.staticGroup();
            // all enemies
            enemies = this.physics.add.group();

            playerGroup = this.physics.add.group();

            var healthbar = this.add.group();


            // background
            let bg = this.add.sprite(0, 0, 'background');

            // change origin to the top-left of the sprite
            bg.setOrigin(0,0);

            player = playerGroup.create(50,this.sys.game.config.height / 2,'spritesheet','knight_f_idle_anim_f0');
            player.setScale(3,3);
            player.anims.play('idle');
            player.setCollideWorldBounds(true);

            princess = statics.create(this.sys.game.config.width / 2,this.sys.game.config.height / 2,'spritesheet','wizzard_f_idle_anim_f1');
            princess.setScale(3.2,3.2);
            princess.tint =  0xcccccc;

            async function createCoin(x,y) {
            var coin;
            coin = ref.physics.add.sprite(x,y,'spritesheet','coin_anim_f0');
            // Since we're making the coin after everyone, we
            // need to ensure its depth here so it doesn't appear on top.
            coin.depth = 0;
            coin.setScale(3.2,3.2);
            coin.anims.play('coinSpin');
            coin.setGravityY(100);
            coin.setVelocityX((Math.random()*500)-250);
            coin.setVelocityY(-1*(Math.random()*150));
            coin.setCollideWorldBounds(true);

            await new Promise(r => setTimeout(() => new function() {
                    coin.setVelocityX(0);
                    coin.setVelocityY(0);
                    coin.setGravityY(0);
                    // Add collider only after coin has landed
                    ref.physics.add.collider(player, coin, collectCoin, null, this);
                }, 2000));

            }

            var heart1 = healthbar.create(30,25,'spritesheet','ui_heart_full');
            heart1.setScale(3.2,3.2);
            var heart2 = healthbar.create(80,25,'spritesheet','ui_heart_full');
            heart2.setScale(3.2,3.2);
            var heart3 = healthbar.create(130,25,'spritesheet','ui_heart_full');
            heart3.setScale(3.2,3.2);


            function createSlime() {
            slime = enemies.create((Math.round(Math.random()) == 0 ? ref.sys.game.config.width + 30 : -30),(Math.round(Math.random()) == 0 ? ref.sys.game.config.height + 30 : -30),'spritesheet','goblin_run_anim_f0');
            slime.setScale(3.2,3.2);
            slime.anims.play('goblinRun');
            slime.health = 100;
            //slime.setCollideWorldBounds(true);
            }

            var spawner = setInterval(createSlime, 5000);


            createSlime();
            createSlime();
            createSlime();
            createSlime();
            createSlime();
            createSlime();

            function deathScreen() {
                let box = ref.add.sprite((ref.sys.game.config.width / 2), (ref.sys.game.config.height / 2), 'box');
                box.setScale(0.4,0.4);
                ref.add.text((ref.sys.game.config.width / 2)-75, (ref.sys.game.config.height / 2)-130, 'YOU', { fontFamily: 'PublicPixel', fontSize:'50px' });
                ref.add.text((ref.sys.game.config.width / 2)-95, (ref.sys.game.config.height / 2)-80, 'LOST', { fontFamily: 'PublicPixel', fontSize:'50px'  });
                

                let retry = ref.add.sprite(ref.sys.game.config.width / 2, (ref.sys.game.config.height / 2)+30, 'retry');
                retry.setScale(0.200,0.200);
                retry.setInteractive();

                retry.on('pointerover', () => { 
                    retry.tint = Math.random() * 0xffffff;
                    retry.setScale(0.201,0.201);
                });

                retry.on('pointerout', () => { 
                    retry.tint = 0xffffff;
                    retry.setScale(0.200,0.200);
                });

                retry.on('pointerdown', () => { 
                    retry.setScale(0.200,0.200);
                    ref.scene.stop('InGame');
                    ref.scene.start('InGame');
                });

                let quit = ref.add.sprite(ref.sys.game.config.width / 2, (ref.sys.game.config.height / 2)+100, 'quit');
                quit.setScale(0.200,0.200);
                quit.setInteractive();

                quit.on('pointerover', () => { 
                    quit.tint = Math.random() * 0xffffff;
                    quit.setScale(0.201,0.201);
                });

                quit.on('pointerout', () => { 
                    quit.tint = 0xffffff;
                    quit.setScale(0.200,0.200);
                });

                quit.on('pointerdown', () => { 
                    quit.setScale(0.200,0.200);
                    ref.scene.launch('Menu');
                    ref.scene.bringToTop('Menu');
                    ref.scene.stop('InGame');
                });

            }


            this.physics.add.collider(player, enemies);
            this.physics.add.collider(player, statics);
            this.physics.add.collider(princess, enemies, hitPrincess, null, this);

            // UI 
            
            var score = 0;
            var scoreText = this.add.text(ref.sys.game.config.width - 40, 10, '0', { fontFamily: 'PublicPixel',fontSize: '30px', fill: '#000',align:'right' });

            var health = 100;

            var gameEnded = Boolean(0);

            function collectCoin(player,coinBody) {
                        console.log("coin");
                        score += 10;
                        scoreText.setText(score);
                        // A trick to right-align.
                        scoreText.x = ref.sys.game.config.width - 10 - (scoreText.width);
                        
                        coinBody.destroy();
            }

            async function hitPrincess(bodyA, bodyB) {
                if(gameEnded)
                    return;

                var xDistance = princess.x-bodyB.x;
                var yDistance = princess.y-bodyB.y;
                var hypotenuse = Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));

                
                var y = -0.8*200*(yDistance/hypotenuse);
                var x = -0.8*200*(xDistance/hypotenuse);

                bodyB.setVelocityX(x);
                bodyB.setVelocityY(y);
                health -= 10;
                // Since there's really no better way to do this
                // other than manually--
                if(health < 85) {
                    heart3.setTexture('spritesheet','ui_heart_half');
                } 
                if(health < 70) {
                    heart3.setTexture('spritesheet','ui_heart_empty');
                }
                if(health < 50) {
                    heart2.setTexture('spritesheet','ui_heart_half');
                }
                if(health < 30) {
                    heart2.setTexture('spritesheet','ui_heart_empty');
                }
                if(health < 15) {
                    heart1.setTexture('spritesheet','ui_heart_half');
                }
                if(health <= 0) {
                    heart1.setTexture('spritesheet','ui_heart_empty');
                }

                if(health <= 0) {
                    gameEnded = Boolean(1);
                    deathScreen();
                    return;
                }
                bodyB.anims.pause();
                this.cameras.main.shake(1000,0.005);


                await new Promise(r => setTimeout(() => new function() {
                    if(bodyB.health > 0) {
                    bodyB.setVelocityX(0);
                    bodyB.setVelocityY(0);
                    bodyB.anims.resume();
                    }
                }, 2000));

                
            }

            sword = playerGroup.create(70,(this.sys.game.config.height / 2)+30,'spritesheet','weapon_rusty_sword');
            sword.setScale(3.2,3.2);
            this.physics.add.collider(sword, enemies, hitEnemies, null, this);

            async function hitEnemies(bodyA, bodyB) {

                if(overrideSword) {
                var xDistance = bodyA.x-bodyB.x;
                var yDistance = bodyA.y-bodyB.y;
                var hypotenuse = Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));

                
                var y = -0.8*200*(yDistance/hypotenuse);
                var x = -0.8*200*(xDistance/hypotenuse);

                bodyB.setVelocityX(x);
                bodyB.setVelocityY(y);
                bodyB.anims.pause();

                bodyB.health -= 10;

                if(bodyB.health <= 0) {
                createCoin(bodyB.x,bodyB.y);
                bodyB.destroy();
                return;
                }
                console.log(bodyB.health);

                bodyB.tint = Math.random() * 0xffffff;

                await new Promise(r => setTimeout(() => new function() {
                    // In case our enemy has died by the time
                    // their knockback is reset.
                    if(bodyB.health > 0) {
                    bodyB.setVelocityX(0);
                    bodyB.setVelocityY(0);
                    bodyB.anims.resume();
                    }
                }, 2000));

                }
            }

            var id;

            this.input.on('pointerdown', async function (pointer) {


            overrideSword = Boolean(1);

            if(sword.angle <= 180) 
                sword.angle = 0;
            else
                sword.angle=360;

            clearInterval(id);

            id = setInterval(frame, 1);

            // Temporary sword trail
            let trail = ref.add.sprite(sword.x, sword.y, 'sword');
            trail.setScale(0.5,0.5);
            trail.anims.play('sword');
            if(player.flipX) {
                trail.setFlipX(true);
            }
            // Destroy after anim done
            //trail.destroy();
    
            function frame() {
            if(player.flipX) {
                    if(sword.angle < -140) {
                    clearInterval(id);
                    return;
                } else {
                    sword.angle-=5; 
                }
            }
            if (!player.flipX) {
                    if(sword.angle > 140) {
                    clearInterval(id);
                    return;
                } else {
                    sword.angle+=5; 
                }
            }
            }

            await new Promise(r => setTimeout(() => new function() {
                    overrideSword = Boolean(0);
                    trail.destroy();

                }, 500));

            }, this);

            getAngle = function getAngle(obj1, obj2) {
            //I use the offset because the sword is pointing down
            //at the 6 o'clock position
            //set to 0 if your sprite is facing 3 o'clock
            //set to 180 if your sprite is facing 9 o'clock
            //set to 270 if your sprite is facing 12 o'clock
            //
            var offSet = 90;
            // angle in radians
            //var angleRadians = Math.atan2(obj2.y - obj1.y, obj2.x - obj1.x);
            // angle in degrees
            var angleDeg = (Math.atan2(obj2.y - obj1.y, obj2.x - obj1.x) * 180 / Math.PI);
            //add the offset
            angleDeg += offSet;
            return angleDeg;
            }

            overrideSword = Boolean(0);

        }

        update(time,delta) {

            var moving = Boolean(0);

            if(player.flipX)
            sword.x = player.x - 10;
            else 
            sword.x = player.x + 10;

            sword.y = player.y + 30;

            if(!overrideSword)
            sword.angle = getAngle(sword,this.sys.game.input.activePointer);

            if(sword.angle > 30 & sword.angle < 150) {
                player.setFlipX(false);
                sword.x = player.x + 15;
            } else if(sword.angle < -30 & sword.angle > -210){
                player.setFlipX(true);
                sword.x = player.x - 15;
            } 

            // Player Movement
            if (cursors.left.isDown)
            {
                playerGroup.setVelocityX(-160);
                player.anims.play('run',true);
                moving = Boolean(1);
                //player.setFlipX(true);
            }
            else if (cursors.right.isDown)
            {
                playerGroup.setVelocityX(160);
                player.anims.play('run',true);
                moving = Boolean(1);
                //player.setFlipX(false);

            }
            else
            {
                moving = Boolean(0);
                playerGroup.setVelocityX(0);
            }

            if (cursors.up.isDown)
            {
                playerGroup.setVelocityY(-160);
                player.anims.play('run',true);
                moving = Boolean(1);

            } else if(cursors.down.isDown) {
                playerGroup.setVelocityY(160);
                player.anims.play('run',true);
                moving = Boolean(1);

            } else
            {
                if(!moving) {
                    player.anims.play('idle',true);
                }
                playerGroup.setVelocityY(0);
            }


                enemies.children['entries'].forEach(enemy => {
                    var xDistance = princess.x-enemy.x;
                    var yDistance = princess.y-enemy.y;
                    var hypotenuse = Math.sqrt((xDistance * xDistance) + (yDistance * yDistance));
                    if(hypotenuse < 1000){
                    enemy.y += 0.008*200*(yDistance/hypotenuse);
                    enemy.x += 0.008*200*(xDistance/hypotenuse);
                    }
                });


            }
        }

        class Menu extends Phaser.Scene {
        
        constructor() {
            super('Menu');
        }

        preload()
        {
            // Called once- never called again
            if(!gameStarted) {
                // A marker to access this class in functions
                gameStarted = Boolean(1);

                // Preloading all game images.
                this.load.image('background', 'assets/grass.png');
                this.load.image('play', 'assets/play.png');
                this.load.image('story', 'assets/story.png');
                this.load.image('shop', 'assets/shop.png');
                this.load.image('quit', 'assets/quit.png');
                this.load.image('settings', 'assets/gear.png');
                this.load.image('x', 'assets/x.png');
                this.load.image('box', 'assets/box.png');
                this.load.atlas('spritesheet', 'assets/fixedphas.png', 'assets/fixedphas.json');
                this.load.image('background', 'assets/grass.png');
                this.load.image('retry', 'assets/retry.png');
                this.load.image('background', 'assets/grass.png');
                this.load.image('resume', 'assets/resume.png');
                this.load.spritesheet('swordtrail', 'assets/swordtrail.png', { frameWidth: 282, frameHeight: 214 });


                console.log(ref);



                // Setting up the Pause Menu
                ref.input.keyboard.on('keydown_ESC', function (event) { 
                console.log('Game Paused');
                if(ref.scene.isActive('PauseMenu')) {
                    ref.scene.stop('PauseMenu');
                    ref.scene.bringToTop('InGame');
                    ref.scene.resume();
                } else {
                    ref.scene.launch('PauseMenu');
                    ref.scene.bringToTop('PauseMenu');
                    ref.scene.pause();   
                }
                });

                // Setting up Movement
            }
        }
        
        create(data) {
            cursors = this.input.keyboard.createCursorKeys();
            let bg = this.add.sprite(0, 0, 'background');
            // change origin to the top-left of the sprite
            bg.setOrigin(0,0);

            //let play = this.add.sprite(this.sys.game.config.width / 2, (this.sys.game.config.height / 2)+100, 'play');
            // change origin to the top-left of the sprite
            var ref = this;

            let play = this.add.sprite(this.sys.game.config.width / 2, (this.sys.game.config.height / 2)+100, 'play');
            play.setScale(0.3,0.3);
            play.setInteractive();

            play.on('pointerover', () => { 
                play.tint = Math.random() * 0xffffff;
                play.setScale(0.31,0.31);

             });

             play.on('pointerout', () => { 
                play.tint = 0xffffff;
                play.setScale(0.3,0.3);

             });

            play.on('pointerdown', () => { 
                play.setScale(0.3,0.3);
                displayMenu();
            });

             function displayMenu() {

                if(play != null)
                play.destroy();

                let story = ref.add.sprite(ref.sys.game.config.width / 2, (ref.sys.game.config.height / 2)-100, 'story');
                story.setScale(0.3,0.3);
                story.setInteractive();

                story.on('pointerover', () => { 
                    story.tint = Math.random() * 0xffffff;
                    story.setScale(0.31,0.31);
                });

                story.on('pointerout', () => { 
                    story.tint = 0xffffff;
                    story.setScale(0.3,0.3);
                });

                story.on('pointerdown', () => { 
                    story.setScale(0.3,0.3);
                    ref.scene.launch('InGame');
                    ref.scene.bringToTop('InGame');
                    ref.scene.stop('Menu');
                });

                let shop = ref.add.sprite(ref.sys.game.config.width / 2, (ref.sys.game.config.height / 2), 'shop');
                shop.setScale(0.3,0.3);
                shop.setInteractive();

                shop.on('pointerover', () => { 
                    shop.tint = Math.random() * 0xffffff;
                    shop.setScale(0.31,0.31);
                });

                shop.on('pointerout', () => { 
                    shop.tint = 0xffffff;
                    shop.setScale(0.3,0.3);
                });

                shop.on('pointerdown', () => { 
                    shop.setScale(0.3,0.3);
                });

                let quit = ref.add.sprite(ref.sys.game.config.width / 2, (ref.sys.game.config.height / 2)+100, 'quit');
                quit.setScale(0.3,0.3);
                quit.setInteractive();

                quit.on('pointerover', () => { 
                    quit.tint = Math.random() * 0xffffff;
                    quit.setScale(0.31,0.31);
                });

                quit.on('pointerout', () => { 
                    quit.tint = 0xffffff;
                    quit.setScale(0.3,0.3);
                });

                quit.on('pointerdown', () => { 
                    quit.setScale(0.3,0.3);
                    ref.scene.stop('Menu');
                    ref.scene.start('Menu');
                });

                let settings = ref.add.sprite(ref.sys.game.config.width-40, (ref.sys.game.config.height-40), 'settings');
                settings.setScale(0.1,0.1);
                settings.setInteractive();

                settings.on('pointerover', () => { 
                    settings.tint = Math.random() * 0xffffff;
                    settings.setScale(0.11,0.11);
                });

                settings.on('pointerout', () => { 
                    settings.tint = 0xffffff;
                    settings.setScale(0.1,0.1);
                });

                settings.on('pointerdown', () => { 
                    settings.setScale(0.1,0.1);
                    story.destroy();
                    shop.destroy();
                    quit.destroy();
                    displaySettings();
                });

                function displaySettings() {

                let box = ref.add.sprite((ref.sys.game.config.width / 2), (ref.sys.game.config.height / 2), 'box');
                box.setScale(0.4,0.4);


                let x = ref.add.sprite((ref.sys.game.config.width / 2)+130, (ref.sys.game.config.height / 2)-155, 'x');
                x.setScale(0.15,0.15);
                x.setInteractive();

                x.on('pointerover', () => { 
                    x.tint = Math.random() * 0xffffff;
                    x.setScale(0.151,0.151);
                });

                x.on('pointerout', () => { 
                    x.tint = 0xffffff;
                    x.setScale(0.15,0.15);
                });

                x.on('pointerdown', () => { 
                    x.setScale(0.15,0.15);
                    x.destroy();
                    box.destroy();
                    displayMenu();
                });

                }


             }

            player = this.physics.add.sprite(50,this.sys.game.config.height / 2,'spritesheet','knight_f_idle_anim_f0');
            player.setScale(2,2);
            var frameNames = this.anims.generateFrameNames('spritesheet', {
                     start: 0, end: 3,
                     prefix: 'knight_f_idle_anim_f'
            });

        }


        update(time,delta) {
        }

        }

        var config = {
            type: Phaser.AUTO,
            width: 640,
            height: 640,
            pixelArt: true,
            physics: {
                default: 'arcade',
                arcade: {
                gravity: { y: 0 }
                }
            },
            scene: [
                Menu,
                InGame,
                PauseMenu
            ]
        };
        var game = new Phaser.Game(config);
        var cursors;
        var player;
        var princess;
        var slime;
        var sword;
        var playerGroup;
        var getAngle;
        var overrideSword;
        var enemies;
        var ref;
        var gameStarted = Boolean(0);
        var preloadedGame = Boolean(0);


    </script>
</body>


</html>